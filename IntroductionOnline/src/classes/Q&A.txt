1. Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса,
а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям
могут быть присвоены начальные значения?
------------------------------------------------------------------------------------------------------------------
Как известно, в Java поля (fields) могут принадлежать классу или объекту. Поля, принадлежащие классу,
являются статическими, а поля, принадлежащие объекту, - нестатическими. Статические поля доступны без создания
объекта класса. Соответственно инициализироваться статические и нестатические поля должны в разное время: одни до
создания объекта класса, а другие после.

Типы инициализации полей объектов и классов
Существуют следующие методы инициализации полей:

Инициализация в месте объявления поля	Поля класса, поля объекта
Применяется, если инициализация может быть произведена коротким выражением и доступен контекст, необходимый для
ее проведения

Инициализационный блок	Поля класса, поля объекта
Применяется, если инициализационный код неудобно записывать одним выражением или же, например, нужна обработка
проверяемых исключений. В случае объектов может применяться для инициализации полей объектов анонимных классов.

Конструктор класса	Поля объекта	Применяется, если для инициализации нужны параметры конструктора

Значения по умолчанию:
int      => 0
boolean  => false
double   => 0.0
float    => 0.0
char     => ' ' - нуль-символ
long     => 0
byte     => 0
reference => null

2. Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы
могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и
производном классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли
перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов?
-----------------------------------------------------------------------------------------------------------------
В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров.
Такой механизм называется перегрузкой методов (method overloading).

3. Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните
правила, которым следует компилятор при разрешении перегрузки; в том числе, если методы перегружаются
примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в
иерархической связи.
------------------------------------------------------------------------------------------------------------------
Итак, фундаментальное различие между статическим и динамическим связыванием в Java состоит в том, что первое
происходит рано, во время компиляции на основе типа ссылочной переменной, а второе – позднее, во время выполнения,
с использованием конкретных объектов.

Статическое связывание происходит во время компиляции, а динамическое – во время выполнения.

Поскольку статическое связывание происходит на ранней стадии жизненного цикла программы, его называют ранним
связыванием. Аналогично, динамическое связывание называют также поздним связыванием, поскольку оно происходит
позже, во время работы программы.

Статическое связывание используется в языке Java для разрешения перегруженных методов, в то время как динамическое
 связывание используется в языке Java для разрешения переопределенных методов.

Аналогично, приватные, статические и терминальные методы разрешаются при помощи статического связывания,
поскольку их нельзя переопределять, а все виртуальные методы разрешаются при помощи динамического связывания.

В случае статического связывания используются не конкретные объекты, а информация о типе, то есть для обнаружения
нужного метода используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения
нужного метода в Java используется конкретный объект.

4. Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких –
нет, и почему?
-------------------------------------------------------------------------------------------------------------------
Если вы возьмете справочник Шилдта по Java, то на 171 странице вы прочитаете о том, что ключевое слово this
требуется для того, чтобы метод мог сослаться на вызвавший его объект.

Как правило, применять this нужно в двух случаях:
Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена;
Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из
другого. Это еще называется явным вызовом конструктора.

this отсутвует в статическиех методах

5. Что такое финальные поля, какие поля можно объявить со спецификатором final? Где можно инициализировать
финальные поля?
-------------------------------------------------------------------------------------------------------------------
С помощью final отмечаются поля, которые инициализируются только один раз.
Инициализировать можно на месте, в контсрукторе или в методах класса, но только 1 раз.

6. Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические
методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?
------------------------------------------------------------------------------------------------------------------
Кроме обычных методов и полей класс может иметь статические поля, методы, константы и инициализаторы.
Для объявления статических переменных, констант, методов и инициализаторов перед их объявлением указывается
ключевое слово static.

При создании объектов класса для каждого объекта создается своя копия нестатических обычных полей. А статические
поля являются общими для всего класса. Поэтому они могут использоваться без создания объектов класса.

Также статическими бывают константы, которые являются общими для всего класса.

Статические инициализаторы предназначены для инициализации статических переменных, либо для выполнения таких
действий, которые выполняются при создании самого первого объекта.

Статические методы также относятся ко всему классу в целом

При использовании статических методов надо учитывать ограничения: в статических методах мы можем вызывать только
другие статические методы и использовать только статические переменные.

статический метод нельзя переопределить. По аналогии с переменными, можно сказать, что этот метод
"один для класса и его наследников" - так же, как статическая переменная "одна для класса и всех его объектов"."

все доступные методы наследуются подклассами.

подкласс наследует все открытые и защищенные члены своего родителя, независимо от того, в каком пакете находится
подкласс. Если подкласс находится в том же пакете, что и его родитель, он также наследует члены package-private
родителя. Наследуемые элементы можно использовать как есть, заменять их, скрывать или дополнять новыми члены

единственное отличие от унаследованных статических (class) методов и унаследованных нестатических (instance)
методов заключается в том, что при написании нового статического метода с той же сигнатурой старый статический
 метод просто скрыт, а не переопределен.

7. Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они
могут быть размещены и в каком порядке вызываются?
-----------------------------------------------------------------------------------------------------------------
Инициализация (от англ. initialize, от  initial - "начальный, первоначальный") - это когда мы впервые задаем
переменной какое-либо значение.

Виды блоков инициализации
Существует всего два типа блоков:
нестатический (instance initializer)
статический (class initializer)

статический блок используется для инициализации статических переменных, а "обычный"  - для всех остальных.

8. Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что
представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании
перегрузки для методов с переменным числом параметров?
----------------------------------------------------------------------------------------------------------------
public method(String...args) {}
args - массив
Чем точнее количество и типы параметров, тот метда и вызывается.

9. Чем является класс Object? Перечислите известные вам методы класса Object, укажите их назначение.
-----------------------------------------------------------------------------------------------------------------
Хотя мы можем создать обычный класс, который не является наследником, но фактически все классы наследуются от
класса Object. Все остальные классы, даже те, которые мы добавляем в свой проект, являются неявно производными
от класса Object. Поэтому все типы и классы могут реализовать те методы, которые определены в классе Object.

toString
Метод toString служит для получения представления данного объекта в виде строки. При попытке вывести строковое
представления какого-нибудь объекта, как правило, будет выводиться полное имя класса. Например:

Метод hashCode
Метод hashCode позволяет задать некоторое числовое значение, которое будет соответствовать данному объекту или
его хэш-код. По данному числу, например, можно сравнивать объекты.

Получение типа объекта и метод getClass
Метод getClass позволяет получить тип данного объекта:

Метод equals
Метод equals сравнивает два объекта на равенство

10. Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?
------------------------------------------------------------------------------------------------------------------
Теперь поговорим о методе hashCode(). Зачем он нужен?

Ровно для той же цели — сравнения объектов. Но ведь у нас уже есть equals()! Зачем же еще один метод?

Ответ прост: для повышения производительности.

Хэш-функция, которая представлена в Java  методом hashCode(), возвращает числовое значение фиксированной длины
для любого объекта. В случае с Java метод hashCode() возвращает для любого объекта 32-битное число типа int.

Сравнить два числа между собой — гораздо быстрее, чем сравнить два объекта методом equals(), особенно если в
нем используется много полей.

Если в нашей программе будут сравниваться объекты, гораздо проще сделать это по хэш-коду, и только если они равны
по hashCode() — переходить к сравнению по equals().

Таким образом, кстати, работают основанные на хеше структуры данных — например, известная тебе HashMap!

По хорошему, у разных объектов хешкод должен быть разный. Но на практике иногда происходит по другому.
Очень часто это происходит из-за несовершенства формулы для вычисления хешкода.

11. Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного
значения с Type.class отличается от использования оператора instanceof?
----------------------------------------------------------------------------------------------------------------
В Java почти все сущности являются объектами, за исключением примитивных типов. У каждого объекта есть класс.
Сами классы тоже является объектами, и они принадлежат классу Class.

У класса Class нет публичных конструкторов. Class - это generic тип. Методы Class предназначены для получения
информации о классе (объекте типа Class). Например, можно узнать полное имя класса, какие у него аннотации,
какие конструкторы и т.п. Эти методы нужны для reflection. С помощью reflection вы можете создавать объекты,
которые принадлежат этому классу, и при этом заранее класс объекта вы можете не знать.

12. Укажите правила переопределения методов equals(), hashCode() и toString().
----------------------------------------------------------------------------------------------------------------
Реализация по умолчанию метода equals() в классе java.lang.Object сравнивает ссылки на адреса в памяти, которые
хранят переменные, и возвращает true только в том случае, если адреса совпадают, другими словами переменные
ссылаются на один и тот же объект.

Java рекомендует переопределять методы equals() и hashCode(), если предполагается, что сравнение должно
осуществляться в соответсвии с естественной логикой или бизнес-логикой. Многие классы в стандартных библиотеках
Java переопределяет их, например в классе String переопределяется equals таким образом, что возвращается true,
если содержимое двух сравниваемых объектов одинаковое. В классе-обертке Integer метод equal переопределяется
для выполнения численного сравнения, и так далее.

Соглашение между equals и hashCode в Java
Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.
Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми,
так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.

toString()- для красоты и удобства.