1. Дайте развернутое объяснение трем концепциям ООП.
---------------------------------------------------------------------------------------------------------------
Принципы ООП:
Наследование
Абстракция
Инкапсуляция
Полиморфизм

Принцип 1. Наследование
Наследование — механизм, который позволяет описать новый класс на основе существующего (родительского). При этом
свойства и функциональность родительского класса заимствуются новым классом.

Для чего нужно наследование и какие преимущества оно дает?
Прежде всего — повторное использование кода. Поля и методы, описанные в родительских классах, можно использовать
в классах-потомках.

Если у всех типов автомобилей есть 10 общих полей и 5 одинаковых методов, тебе достаточно вынести их в родительский
класс Auto. Ты сможешь использовать их в классах-потомках безо всяких проблем.

Сплошные плюсы: и количественно (меньше кода), и, как следствие, качественно (классы становятся гораздо проще).
При этом механизм наследования очень гибкий, и недостающую в потомках функциональность ты можешь дописать отдельно
(какие-то специфические для конкретного класса поля или поведение).

В общем, как и в обычной жизни: все мы чем-то похожи на наших родителей, а чем-то отличаемся от них :)

Принцип 2. Абстракция
Это очень простой принцип. Абстракция означает выделение главных, наиболее значимых характеристик предмета и
наоборот — отбрасывание второстепенных, незначительных.

Не будем изобретать велосипед и вспомним пример из старой лекции про классы.

Скажем, мы создаем картотеку работников компании. Для создания объектов «работник» мы написали класс Employee.
Какие характеристики важны для их описания в картотеке компании? ФИО, дата рождения, номер социального страхования,
ИНН. Но вряд ли в карточке такого типа нам нужны его рост, цвет глаз и волос. Компании эта информация о сотруднике
ни к чему.

Поэтому для класса Employee мы зададим переменные String name, int age, int socialInsuranceNumber и int taxNumber,
а от лишней для нас информации вроде цвета глаз откажемся, абстрагируемся.

А вот если мы создаем картотеку фотомоделей для агентства, ситуация резко меняется. Для описания фотомодели нам
как раз очень важны рост, цвет глаз и цвет волос, а номер ИНН не нужен.
Поэтому в классе Model мы создаем переменные String height, String hair, String eyes.

Принцип 3. Инкапсуляция
Инкапсуляция в Java означает ограничение доступа к данным и возможностям их изменения.

Как видишь, в его основе лежит слово «капсула». В эту «капсулу» мы прячем какие-то важные для нас данные, которые
не хотим, чтобы кто-то менял.

Простой пример из жизни. У тебя есть имя и фамилия. Их знают все твои знакомые. Но у них нет доступа к изменению
твоего имени и фамилии. Этот процесс, можно сказать, «инкапсулирован» в паспортном столе: поменять имя фамилию
можно только там, и сделать это можешь только ты. Остальные «пользователи» имеют доступ к твоему имени и фамилии
«только на чтение» :)

Еще один пример — деньги в твоей квартире. Оставлять их на виду посреди комнаты — не лучшая идея.
Любой «пользователь» (человек, пришедший к тебе домой) сможет изменить число твоих денег, т.е. забрать их.
Лучше инкапсулировать их в сейфе. Доступ будет только у тебя и только по специальному коду.

Очевидные примеры инкапсуляции, с которыми ты уже работал, — это модификаторы доступа (private, public и т.д.),
а также геттеры-сеттеры.

Принцип 4. Полиморфизм
Полиморфизм — это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение
объектов будет разным в зависимости от типа, к которому они принадлежат.

Звучит сложновато? Сейчас разберемся.
Возьмем самый простой пример — животных. Создадим класс Animal с единственным методом — voice(), и двух его
наследников — Cat и Dog.

public class Animal {
   public void voice() {
       System.out.println("Голос!");
   }
}

public class Dog extends Animal {
   @Override
   public void voice() {
       System.out.println("Гав-гав!");
   }
}

public class Cat extends Animal {
   @Override
   public void voice() {
       System.out.println("Мяу!");
   }
}

Теперь попробуем создать ссылку Animal и присвоить ей объект Dog.

public class Main {
   public static void main(String[] args) {
       Animal dog = new Dog();
       dog.voice();
   }
}

Как ты думаешь, какой метод будет вызван? Animal.voice() или Dog.voice()?
Будет вызван метод класса Dog:
Гав-гав!

Мы создали ссылку Animal, но объект ведет себя как Dog. При необходимости он может вести себя как кошка, лошадь
или другое животное. Главное — присвоить ссылке общего типа Animal объект конкретного класса-наследника.
Это логично, ведь все собаки являются животными.

Именно это мы имели в виду, когда говорили «поведение объектов будет разным, в зависимости от того,
к какому типу они принадлежат».

2. Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса, а
когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть
присвоены начальные значения?
-----------------------------------------------------------------------------------------------------------------
Как известно, в Java поля (fields) могут принадлежать классу или объекту. Поля, принадлежащие классу,
являются статическими, а поля, принадлежащие объекту, - нестатическими. Статические поля доступны без создания
объекта класса. Соответственно инициализироваться статические и нестатические поля должны в разное время: одни до
создания объекта класса, а другие после.

Типы инициализации полей объектов и классов
Существуют следующие методы инициализации полей:

Инициализация в месте объявления поля	Поля класса, поля объекта
Применяется, если инициализация может быть произведена коротким выражением и доступен контекст, необходимый для
ее проведения

Инициализационный блок	Поля класса, поля объекта
Применяется, если инициализационный код неудобно записывать одним выражением или же, например, нужна обработка
проверяемых исключений. В случае объектов может применяться для инициализации полей объектов анонимных классов.

Конструктор класса	Поля объекта	Применяется, если для инициализации нужны параметры конструктора

Значения по умолчанию:
int      => 0
boolean  => false
double   => 0.0
float    => 0.0
char     => ' ' - нуль-символ
long     => 0
byte     => 0
reference => null

3. Приведите правила, которым должен следовать компонент java-bean.
-----------------------------------------------------------------------------------------------------------------
Bean по-английски боб. А Java Beans – это, стало быть, кофейные бобы (Java – сорт кофе). Такой айтишный юмор.

Бизнес-логику программы представляли в виде набора высокоуровневых объектов – бинов, которые умели обмениваться
сообщениями, сохранять себя, находить друг друга по имени, и еще кучу всего. Обычно это достигалось за счет
специального супер-навороченного родительского класса, хотя были и другие подходы. Поведение таких объектов
очень регламентировалось.

Три самых известных вида EJB-бинов:

Entity Bean – бин, цель которого — хранить некоторые данные. В логику такого бина встроен механизм сохранения
себя и своих полей в базу данных. Такой объект может быть уничтожен, а потом воссоздан из базы заново. Но кроме
хранения данных у него нет никакой логики.

Session Bean – это функциональный бин. У каждого Session Bean есть своя функция. Один делает одно, другой другое.
Такие бины работают с другими объектам и бинами, а не со своими данными.

Session Beans делятся на две категории.
Stateless Session Bean – это бин, который не хранит во внутренних переменных важных данных, нужных для его работы.
Такой бин можно уничтожить, а затем заново создать, и он будет выполнять свою функцию, как и раньше.

Statefull Session Bean – это бин, который хранит у себя внутри данные, которые использует при работе. Если мы
вызываем методы этого бина, то в каждом следующем вызове он может использовать часть данных, переданных ему в
предыдущих. И все равно этот бин – это не то же самое, что обычный объект.

Но в использовании бинов тоже было не все так радужно, поэтому скоро маятник качнулся в обратную сторону.
И разработчики стали все чаще использовать обычные объекты. Им даже придумали специальное название.

4. Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут
перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном
классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли перегрузить
конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов?
------------------------------------------------------------------------------------------------------------------
В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров.
Такой механизм называется перегрузкой методов (method overloading).

5. Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила,
которым следует компилятор при разрешении перегрузки; в том числе, если методы перегружаются примитивными
типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи.
------------------------------------------------------------------------------------------------------------------
Итак, фундаментальное различие между статическим и динамическим связыванием в Java состоит в том, что первое
происходит рано, во время компиляции на основе типа ссылочной переменной, а второе – позднее, во время выполнения,
с использованием конкретных объектов.

Статическое связывание происходит во время компиляции, а динамическое – во время выполнения.

Поскольку статическое связывание происходит на ранней стадии жизненного цикла программы, его называют ранним
связыванием. Аналогично, динамическое связывание называют также поздним связыванием, поскольку оно происходит
позже, во время работы программы.

Статическое связывание используется в языке Java для разрешения перегруженных методов, в то время как динамическое
 связывание используется в языке Java для разрешения переопределенных методов.

Аналогично, приватные, статические и терминальные методы разрешаются при помощи статического связывания,
поскольку их нельзя переопределять, а все виртуальные методы разрешаются при помощи динамического связывания.

В случае статического связывания используются не конкретные объекты, а информация о типе, то есть для обнаружения
нужного метода используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения
нужного метода в Java используется конкретный объект.

6. Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и
почему?
------------------------------------------------------------------------------------------------------------------
Если вы возьмете справочник Шилдта по Java, то на 171 странице вы прочитаете о том, что ключевое слово this
требуется для того, чтобы метод мог сослаться на вызвавший его объект.

Как правило, применять this нужно в двух случаях:
Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена;
Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из
другого. Это еще называется явным вызовом конструктора.

this отсутвует в статическиех методах

7. Что такое финальные поля, какие поля можно объявить со спецификатором final? Где можно инициализировать
финальные поля?
-----------------------------------------------------------------------------------------------------------------
С помощью final отмечаются поля, которые инициализируются только один раз.
Инициализировать можно на месте, в контсрукторе или в методах класса, но только 1 раз.

8. Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические
методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?
------------------------------------------------------------------------------------------------------------------
Кроме обычных методов и полей класс может иметь статические поля, методы, константы и инициализаторы.
Для объявления статических переменных, констант, методов и инициализаторов перед их объявлением указывается
ключевое слово static.

При создании объектов класса для каждого объекта создается своя копия нестатических обычных полей. А статические
поля являются общими для всего класса. Поэтому они могут использоваться без создания объектов класса.

Также статическими бывают константы, которые являются общими для всего класса.

Статические инициализаторы предназначены для инициализации статических переменных, либо для выполнения таких
действий, которые выполняются при создании самого первого объекта.

Статические методы также относятся ко всему классу в целом

При использовании статических методов надо учитывать ограничения: в статических методах мы можем вызывать только
другие статические методы и использовать только статические переменные.

статический метод нельзя переопределить. По аналогии с переменными, можно сказать, что этот метод
"один для класса и его наследников" - так же, как статическая переменная "одна для класса и всех его объектов"."

все доступные методы наследуются подклассами.

подкласс наследует все открытые и защищенные члены своего родителя, независимо от того, в каком пакете находится
подкласс. Если подкласс находится в том же пакете, что и его родитель, он также наследует члены package-private
родителя. Наследуемые элементы можно использовать как есть, заменять их, скрывать или дополнять новыми члены

единственное отличие от унаследованных статических (class) методов и унаследованных нестатических (instance)
методов заключается в том, что при написании нового статического метода с той же сигнатурой старый статический
 метод просто скрыт, а не переопределен.

9. Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут
быть размещены и в каком порядке вызываются?
------------------------------------------------------------------------------------------------------------------
Инициализация (от англ. initialize, от  initial - "начальный, первоначальный") - это когда мы впервые задаем
переменной какое-либо значение.

Виды блоков инициализации
Существует всего два типа блоков:
нестатический (instance initializer)
статический (class initializer)

статический блок используется для инициализации статических переменных, а "обычный"  - для всех остальных.

10. Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что
представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании
перегрузки для методов с переменным числом параметров?
-----------------------------------------------------------------------------------------------------------------
public method(String...args) {}
args - массив
Чем точнее количество и типы параметров, тот метда и вызывается.
11. Чем является класс Object? Перечислите известные вам методы класса Object, укажите их назначение.
-----------------------------------------------------------------------------------------------------------------
Хотя мы можем создать обычный класс, который не является наследником, но фактически все классы наследуются от
класса Object. Все остальные классы, даже те, которые мы добавляем в свой проект, являются неявно производными
от класса Object. Поэтому все типы и классы могут реализовать те методы, которые определены в классе Object.

toString
Метод toString служит для получения представления данного объекта в виде строки. При попытке вывести строковое
представления какого-нибудь объекта, как правило, будет выводиться полное имя класса. Например:

Метод hashCode
Метод hashCode позволяет задать некоторое числовое значение, которое будет соответствовать данному объекту или
его хэш-код. По данному числу, например, можно сравнивать объекты.

Получение типа объекта и метод getClass
Метод getClass позволяет получить тип данного объекта:

Метод equals
Метод equals сравнивает два объекта на равенство

12. Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?
------------------------------------------------------------------------------------------------------------------
Теперь поговорим о методе hashCode(). Зачем он нужен?

Ровно для той же цели — сравнения объектов. Но ведь у нас уже есть equals()! Зачем же еще один метод?

Ответ прост: для повышения производительности.

Хэш-функция, которая представлена в Java  методом hashCode(), возвращает числовое значение фиксированной длины
для любого объекта. В случае с Java метод hashCode() возвращает для любого объекта 32-битное число типа int.

Сравнить два числа между собой — гораздо быстрее, чем сравнить два объекта методом equals(), особенно если в
нем используется много полей.

Если в нашей программе будут сравниваться объекты, гораздо проще сделать это по хэш-коду, и только если они равны
по hashCode() — переходить к сравнению по equals().

Таким образом, кстати, работают основанные на хеше структуры данных — например, известная тебе HashMap!

По хорошему, у разных объектов хешкод должен быть разный. Но на практике иногда происходит по другому.
Очень часто это происходит из-за несовершенства формулы для вычисления хешкода.

13. Как вы думаете, для чего используется наследование классов в java-программе? Приведите пример наследования. Как
вы думаете, поля и методы, помеченными модификатором доступа private, наследуются?
-------------------------------------------------------------------------------------------------------------------
Private поля не наследуются.

см. вопрос номер 1

14. Укажите, как вызываются конструкторы при создании объекта производного класса? Что в конструкторе класса делает
оператор super()? Возможно ли в одном конструкторе использовать операторы super() и this()?
------------------------------------------------------------------------------------------------------------------
Cat cat = new Cat();

Сначала для хранения объекта выделяется память.
Далее Java-машина создает ссылку на этот объект (в нашем случае ссылка — это Cat cat).
В завершение происходит инициализация переменных и вызов конструктора (этот процесс мы рассмотрим подробнее).
Первое что произойдет — проинициализируются статические переменные класса
После инициализации статических переменных класса-предка инициализируются статические переменные класса-потомка
Третьими по счету будут инициализированы нестатические переменные класса-предка.
Наконец, дело дошло до конструкторов! Точнее, до конструктора базового класса. Начало его работы — четвертый пункт
в процессе создания объекта.
Теперь пришла очередь инициализации нестатических полей класса-потомка
Вызывается конструктор дочернего класса

super - вызывает коструктор родителя. Должен стоять первым операторв в контсрукторе потомке.

Да, возможно исопльзовать super и this в одном конструкторе.

15. Объясните, как вы понимаете утверждения: “ссылка базового класса может ссылаться на объекты своих производных
типов” и “объект производного класса может быть использован везде, где ожидается объект его базового типа”. Верно
ли обратное и почему?
------------------------------------------------------------------------------------------------------------------
Полиморфизм. см. вопрос 1.

16. Что такое переопределение методов? Как вы думаете, зачем они нужны? Можно ли менять возвращаемый тип при
переопределении методов? Можно ли менять атрибуты доступа при переопределении методов? Можно ли переопределить
методы в рамках одного класса?
-----------------------------------------------------------------------------------------------------------------
Если в иерархии классов совпадают имена и сигнатуры типов методов из подкласса и суперкласса, то говорят,
что метод из подкласса переопределяет метод из суперкласса.
Переопределение методов выполняется только в том случае, если имена и сигнатуры типов обоих методов одинаковы.
В противном случае оба метода считаются перегружаемыми.

17. Определите правило вызова переопределенных методов. Можно ли статические методы переопределить нестатическими
и наоборот?
------------------------------------------------------------------------------------------------------------------
Переопределение метода (англ. Method overriding) в объектно-ориентированном программировании — одна из возможностей
языка программирования, позволяющая подклассу или дочернему классу обеспечивать специфическую реализацию метода,
уже реализованного в одном из суперклассов или родительских классов.

У переопределенного метода должны быть те же аргументы, что и у метода родителя.
У переопределенного метода должны быть тот же тип возвращаемого значения, что и у метода родителя
Модификатор доступа у переопределенного метода также не может отличаться от «оригинального»:

Нет. Статическеи метода нестатическими переопеделять нельзя

18. Какие свойства имеют финальные методы и финальные классы? Как вы думаете, зачем их использовать?
------------------------------------------------------------------------------------------------------------------
Класс, помеченный как final, не поддается наследованию и все его методы косвенным образом приобретают свойство
final.

Употребление модификатора final в объявлении метода или класса накладывает серьезные ограничения на возможность
дальнейшего использования и развития кода. Применение final в объявлении метода – это верный показатель того,
что реализация метода самодостаточна и полностью завершена. Другие программисты, которые захотят воспользоваться
вашим классом, расширив его функции в угоду собственным потребностям, будут стеснены в выборе средств достижения
цели либо полностью лишены таковых. Пометив признаком final класс в целом, вы запретите возможность его наследования
и, вероятно, существенно снизите его практическую ценность для других. Собравшись применить модификатор final,
убедитесь, готовы ли ВЫ к подобным жертвам и стоит ли их принести.

19. Укажите правила приведения типов при наследовании. Напишите примеры явного и неявного преобразования ссылочных
типов. Объясните, какие ошибки могут возникать при явном преобразовании ссылочных типов.
-----------------------------------------------------------------------------------------------------------------
Приведение типов
Иногда ссылку на объект требуется привести к типу другого класса. Для такого приведения типов существует только
одна причина: необходимость использовать все функциональные возможности объекта после того, как его фактический
тип был на время забыт.

В процессе своей работы компилятор проверяет, не обещаете ли вы слишком много, сохраняя значение в переменной.
Так, если  вы присваиваете переменной суперкласса ссылку на объект подкласса, то обещаете меньше положенного, и
компилятор разрешает сделать это. А если вы присваиваете объект суперкласса переменной подкласса, то обещаете
больше положенного, и поэтому вы должны подтвердить свои обещания, указа в скобках имя класса для приведения типов.

Правила приведения типов при наследовании:
Приведение типов можно выполнять только  в иерархии наследования
Для того, чтобы проверить корректность приведения суперкласса к подклассу, следует выполнить операцию instanceof
Но в целом при наследовании лучше свести к минимуму приведение типов и выполнении операции instanceof.

20. Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного значения
с Type.class отличается от использования оператора instanceof?
-----------------------------------------------------------------------------------------------------------------
В Java почти все сущности являются объектами, за исключением примитивных типов. У каждого объекта есть класс.
Сами классы тоже является объектами, и они принадлежат классу Class.

У класса Class нет публичных конструкторов. Class - это generic тип. Методы Class предназначены для получения
информации о классе (объекте типа Class). Например, можно узнать полное имя класса, какие у него аннотации,
какие конструкторы и т.п. Эти методы нужны для reflection. С помощью reflection вы можете создавать объекты,
которые принадлежат этому классу, и при этом заранее класс объекта вы можете не знать.

21. Укажите правила переопределения методов equals(), hashCode() и toString().
------------------------------------------------------------------------------------------------------------------
Реализация по умолчанию метода equals() в классе java.lang.Object сравнивает ссылки на адреса в памяти, которые
хранят переменные, и возвращает true только в том случае, если адреса совпадают, другими словами переменные
ссылаются на один и тот же объект.

Java рекомендует переопределять методы equals() и hashCode(), если предполагается, что сравнение должно
осуществляться в соответсвии с естественной логикой или бизнес-логикой. Многие классы в стандартных библиотеках
Java переопределяет их, например в классе String переопределяется equals таким образом, что возвращается true,
если содержимое двух сравниваемых объектов одинаковое. В классе-обертке Integer метод equal переопределяется
для выполнения численного сравнения, и так далее.

Соглашение между equals и hashCode в Java
Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.
Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми,
так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.

toString()- для красоты и удобства.

22. Что такое абстрактные классы и методы? Зачем они нужны? Бывают ли случаи, когда абстрактные методы содержат тело?
Можно ли в абстрактных классах определять конструкторы? Могут ли абстрактные классы содержать неабстрактные
методы? Можно ли от абстрактных классов создавать объекты и почему?
------------------------------------------------------------------------------------------------------------------
Так вот, абстрактный класс — это максимально абстрактная, о-о-о-чень приблизительная «заготовка» для группы
будущих классов. Эту заготовку нельзя использовать в готовом виде — слишком «сырая». Но она описывает некое
общее состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса.

Примеры абстрактных классов Java
Рассмотрим простой пример с машинами:

public abstract class Car {
   private String model;
   private String color;
   private int maxSpeed;
   public abstract void gas();
   public abstract void brake();
   public String getModel() {
       return model;
   }
   public void setModel(String model) {
       this.model = model;
   }
   public String getColor() {
       return color;
   }
   public void setColor(String color) {
       this.color = color;
   }
   public int getMaxSpeed() {
       return maxSpeed;
   }
   public void setMaxSpeed(int maxSpeed) {
       this.maxSpeed = maxSpeed;
   }
}

Вот так выглядит самый простой абстрактный класс. Как видишь, ничего особенного :)
Для чего он может нам понадобиться?
Прежде всего, он максимально абстрактно описывает нужную нам сущность — автомобиль. Слово abstract находится здесь
недаром. В мире не существует «просто машин». Есть грузовики, гоночные автомобили, седаны, купе, внедорожники.
Наш абстрактный класс — это просто «чертеж», по которому мы позже будем создавать классы-автомобили.

Да, в абстрактном классе в Java можно объявить и определить конструкторы. Поскольку создавать экземпляры
абстрактных классов нельзя, вызвать такой конструктор можно только при формировании цепочки конструкторов,
то есть при создании экземпляра конкретного класса-реализации.

23. Что такое интерфейсы? Как определить и реализовать интерфейс в java-программе? Укажите спецификаторы, которые
приобретают методы и поля, определенные в интерфейсе. Можно ли описывать в интерфейсе конструкторы и создавать
объекты? Можно ли создавать интерфейсные ссылки и если да, то на какие объекты они могут ссылаться?
------------------------------------------------------------------------------------------------------------------
Создание интерфейса очень похоже на создание обычного класса, только вместо слова class мы указываем слово interface.
Давай посмотрим на простейший Java-интерфейс, и разберемся, как он работает и для чего нужен:

public interface Swimmable  {
     public void swim();
}

Мы создали интерфейс Swimmable — «умеющий плавать». Это что-то вроде нашего пульта, у которого есть одна «кнопка»:
метод swim()  — «плыть».

Для этого метод, т.е. кнопку нашего пульта, нужно имплементировать. Чтобы использовать интерфейс, его методы должны
реализовать какие-то классы нашей программы.

Давай придумаем класс, объекты которого подойдут под описание «умеющий плавать». Например, подойдет класс утки — Duck:

public class Duck implements Swimmable {
    public void swim() {
        System.out.println("Уточка, плыви!");
    }
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.swim();
    }
}

Что же мы здесь видим?
Класс Duck «связывается» с интерфейсом Swimmable при помощи ключевого слова implements. Если помнишь, мы
использовали похожий механизм для связи двух классов в наследовании, только там было слово «extends».
«public class Duck implements Swimmable» можно для понятности перевести дословно: «публичный класс Duck реализует
интерфейс Swimmable».

Это значит, что класс, связанный с каким-то интерфейсом, должен реализовать все его методы. Обрати внимание:
в нашем классе Duck прямо как в интерфейсе Swimmable есть метод swim(), и внутри него содержится какая-то логика.

Конструкторы не нельзя объявить в интерфейсах

Проблема, возникающая при разрешении конструкторов в интерфейсах, возникает из-за возможности реализовать
несколько интерфейсов одновременно. Когда класс реализует несколько интерфейсов, которые определяют разные
конструкторы, класс должен будет реализовать несколько конструкторов, каждый из которых удовлетворяет только
одному интерфейсу, но не другим. Невозможно построить объект, который вызывает каждый из этих конструкторов.

При создании объектов класса в качестве типа объектной переменной может указываться имя реализованного в классе
интерфейса. Другими словами, если класс реализует интерфейс, то ссылку на объект этого класса можно присвоить
интерфейсной переменной — переменной, в качестве типа которой указано имя соответствующего интерфейса. Ситуация
очень напоминает ту, что рассматривалась в предыдущей главе при наследовании, когда объектная переменная суперкласса
 ссылалась на объект подкласса. Как и в случае с объектными ссылками суперкласса, через интерфейсную ссылку можно
 сослаться не на все члены объекта реализующего интерфейс класса. Доступны только те методы, которые объявлены в
 соответствующем интерфейсе. С учетом того, что класс может реализовать несколько интерфейсов, а один и тот же
 интерфейс может быть реализован в разных классах, ситуация представляется достаточно пикантной.

24. Для чего служит интерфейс Clonable? Как правильно переопределить метод clone() класса Object, для того, что объект
мог создавать свои адекватные копии?

Иногда необходимо получить копию объекта, которая не зависела бы от оригинала. С которой можно было бы производить
манипуляции, при этом, не изменяя оригинал. При обыкновенном присваивание объектов (obj1 = obj2;) передаются ссылки
на объект. В итоге два экземпляра ссылаются на один объект, и изменение одного приведет к изменению другого.
Как мы видим это не то, что нам нужно. И в данном случае, нам на помощь придет интерфейс Cloneable и метод clone()
класса Object.

И так, если нам необходимо получить независимый клон объекта, то необходимо вызвать метод clone(). Данный метод
объявлен, как protected, а это значит, что метод защищен, и может быть доступен только при наследовании объекта.
Как выясняется, это не является проблемой, потому как любой класс, является потомком класса Object.
Однако при защищенном методе класс может клонировать только свои собственные объекты. Чтобы клонировать другие
объекты, метод clone() необходимо расширить до public.

Пример расширения метода clone().
       public User clone() throws CloneNotSupportedException {
             return (User)super.clone();
       }

Как мы можем видеть метод clone() может выбрасывать исключение CloneNotSupportedException. Данное исключение
возникает в случае, когда клонируемый класс не имеет реализации интерфейса Cloneable. Интерфейс Cloneable не
реализует ни одного метода. Он является всего лишь маркером, говорящим, что данный класс реализует клонирование
объекта.
Само клонирование осуществляется вызовом родительского метода clone(). Данный вид клонирования называется
поверхностным клонированием. Его можно использовать только в том случае, если у клонируемого класса объявлены
неизменяемые типы объекты.

Смотри, если ты хочешь воспользоваться «клонированием по умолчанию», которое реализовано в классе Object, тебе нужно:

а) Добавить интерфейс Cloneable своему классу
б) Переопределить метод clone и вызвать в нем базовую реализацию:

class Point implements Cloneable
{
 int x;
 int y;

 public Object clone()
 {
  return super.clone();
 }
}

Или ты можешь написать реализацию метода clone полностью сам:
class Point
{
 int x;
 int y;

 public Object clone()
 {
  Point point = new Point();
  point.x = this.x;
  point.y = this.y;
  return point;
 }
}


25. Для чего служат интерфейсы Comparable и Comparator? В каких случаях предпочтительнее использовать первый, а когда
– второй? Как их реализовать и использовать?
Д
ля того, чтобы объекты Person можно было сравнить и сортировать, они должны применять интерфейс Comparable<E>.
При применении интерфейса он типизируется текущим классом. Применим его к классу Person:

class Person implements Comparable<Person>{
    private String name;
    Person(String name){

        this.name = name;
    }
    String getName(){return name;}

    public int compareTo(Person p){

        return name.compareTo(p.getName());
    }
}

Интерфейс Comparable содержит один единственный метод int compareTo(E item), который сравнивает текущий объект с
объектом, переданным в качестве параметра. Если этот метод возвращает отрицательное число, то текущий объект будет
располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот,
после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.

В данном случае мы не возвращаем явным образом никакое число, а полагаемся на встроенный механизм сравнения,
который есть у класса String. Но мы также можем определить и свою логику, например, сравнивать по длине имени:

public int compareTo(Person p){
         return name.length()-p.getName().length();
}

Теперь мы можем типизировать TreeSet типом Person и добавлять в дерево соответствующие объекты:
TreeSet<Person> people = new TreeSet<Person>();
people.add(new Person("Tom"));

Интерфейс Comparator
Однако перед нами может возникнуть проблема, что если разработчик не реализовал в своем классе, который мы хотим
использовать, интерфейс Comparable, либо реализовал, но нас не устраивает его функциональность, и мы хотим ее
переопределить? На этот случай есть еще более гибкий способ, предполагающий применение интерфейса Comparator<E>.

Интерфейс Comparator содержит ряд методов, ключевым из которых является метод compare():

public interface Comparator<E> {

    int compare(T a, T b);
    // остальные методы
}
Метод compare также возвращает числовое значение - если оно отрицательное, то объект a предшествует объекту b,
иначе - наоборот. А если метод возвращает ноль, то объекты равны. Для применения интерфейса нам вначале надо
создать класс компаратора, который реализует этот интерфейс:

class PersonComparator implements Comparator<Person>{
    public int compare(Person a, Person b){
      return a.getName().compareTo(b.getName());
    }
}
Здесь опять же проводим сравнение по строкам. Теперь используем класс компаратора для создания объекта TreeSet:

PersonComparator pcomp = new PersonComparator();
TreeSet<Person> people = new TreeSet<Person>(pcomp);
people.add(new Person("Tom"));
people.add(new Person("Nick"));
people.add(new Person("Alice"));
people.add(new Person("Bill"));
for(Person  p : people){
    System.out.println(p.getName());
}
Для создания TreeSet здесь используется одна из версий конструктора, которая в качестве параметра принимает
компаратор. Теперь вне зависимости от того, реализован ли в классе Person интерфейс Comparable, логика сравнения и
сортировки будет использоваться та, которая определена в классе компаратора.

---------------------------------------
Generic classes and Interfaces, Enums
---------------------------------------

1. Что такое перечисления в Java. Как объявить перечисление? Чем являются элементы перечислений? Кто и когда создает
экземпляры перечислений?
------------------------------------------------------------------------------------------------------------------
Кроме отдельных примитивных типов данных и классов в Java есть такой тип как enum или перечисление. Перечисления
представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора enum,
после которого идет название перечисления. Затем идет список элементов перечисления через запятую:

enum Day{
     MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
Перечисление фактически представляет новый тип, поэтому мы можем определить переменную данного типа и использовать ее

Объявляя enum мы неявно создаем класс производный от java.lang.Enum. Условно конструкция enum Season { ... }
эквивалентна class Season extends java.lang.Enum { ... }. И хотя явным образом наследоваться от java.lang.Enum нам
не позволяет компилятор, все же в том, что enum наследуется, легко убедиться с помощью reflection

2. Можно ли самостоятельно создать экземпляр перечисления? А ссылку типа перечисления? Как сравнить, что в двух
переменных содержится один и тот же элемент перечисления и почему именно так?
------------------------------------------------------------------------------------------------------------------
Вы не можете создавать экземпляры Enum вне границ Enum, поскольку у Enum нет public конструктора, и компилятор
не позволит вам внести любой подобный конструктор. Так как компилятор генерирует большинство кода в ответ
на декларацию Enum типа, он не допускает public конструкторов внутри Enum, что заставляет объявлять экземпляры
Enum внутри себя.

Можем ли мы указать конструктор внутри Enum?
Этот вопрос часто следует за предыдущим. Да, вы можете, но помните, что подобное возможно лишь с указанием private
или package-private конструкторов. Конструкторы с public и protected — не допустимы в Enum.

Что лучше использовать для сравнения enum’ов — == или equals()?

Они же оба работают, верно?
Да. Как написано в документации, “допустимо использовать оператор == вместо метода equals, если доподлинно
известно, что хотя бы один из них ссылается на перечислимый тип” (“it is permissible to use the == operator in
place of the equals method when comparing two object references if it is known that at least one of them refers to a
n enum constant”). Причина этого очень простая — каждый из объектов enum’а создаётся только единожды, и поэтому,
если вы создадите десять переменных равных SomeEnum.RED, они все будут ссылаться на один и тот же объект
(а оператор == как раз это и проверяет).

3. Что такое анонимные классы?
------------------------------------------------------------------------------------------------------------------
Анонимные классы объявляются без указания в коде имени класса.
Анонимные классы могут быть созданы:

1) как реализация интерфейса

public class Foo {
    // Анонимный класс, который реализует интерфейс SayHello
    static SayHello h = new SayHello() {
        @Override
        public void say() {
            System.out.println("Метод внутреннего анонимного класса");
        }
    };

    public static void main(String[] args) {
        h.say();
    }
}
// somewhere
interface SayHello {
    void say();
}

На практике, чаще, реализуют функциональные интерфейсы, с помощью анонимных классов, не смотря на наличие лямбд.

2) как наследник определённого класса
<!-- end list -->
public class External {
    // Анонимный класс наследуется от класса Foo
    static Foo foo = new Foo() {
        @Override
        public void show() {
            super.show();
            System.out.println("Метод внутреннего анонимного класса");
        }
    };
    public static void main(String[] args) {
        foo.show();
    }
}

class Foo {
    public void show() {
        System.out.println("Метод суперкласса");
    }
}

4. Что такое параметризованные классы? Для чего они необходимы? Приведите пример параметризованного класса и пример
создания объекта параметризованного класса? Объясните, ссылки какого типа могут ссылаться на объекты
параметризованных классов? Можно ли создать объект, параметризовав его примитивным типом данных?
------------------------------------------------------------------------------------------------------------------
class Account<T>{

    private T id;
    private int sum;

    Account(T id, int sum){
        this.id = id;
        this.sum = sum;
    }

    public T getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}
С помощью буквы T в определении класса class Account<T> мы указываем, что данный тип T будет использоваться этим
классом. Параметр T в угловых скобках называется универсальным параметром, так как вместо него можно подставить
любой тип. При этом пока мы не знаем, какой именно это будет тип: String, int или какой-то другой. Причем буква T
выбрана условно, это может и любая другая буква или набор символов.

После объявления класса мы можем применить универсальный параметр T: так далее в классе объявляется переменная
этого типа, которой затем присваивается значение в конструкторе.

Метод getId() возвращает значение переменной id, но так как данная переменная представляет тип T, то данный
метод также возвращает объект типа T: public T getId().

Используем данный класс:
public class Program{

    public static void main(String[] args) {

        Account<String> acc1 = new Account<String>("2345", 5000);
        String acc1Id = acc1.getId();
        System.out.println(acc1Id);

        Account<Integer> acc2 = new Account<Integer>(2345, 5000);
        Integer acc2Id = acc2.getId();
        System.out.println(acc2Id);
    }
}
class Account<T>{

    private T id;
    private int sum;

    Account(T id, int sum){
        this.id = id;
        this.sum = sum;
    }

    public T getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}
При определении переменной даннного класса и создании объекта после имени класса в угловых скобках нужно указать,
какой именно тип будет использоваться вместо универсального параметра. При этом надо учитывать, что они работают
только с объектами, но не работают с примитивными типами. То есть мы можем написать Account<Integer>, но не можем
использовать тип int или double, например, Account<int>. Вместо примитивных типов надо использовать
классы-обертки: Integer вместо int, Double вместо double и т.д.

--------------------------
Exceptions and Errors
-----------------------------------------

1. Что для программы является исключительной ситуацией? Какие способы обработки ошибок в программах вы знаете?
------------------------------------------------------------------------------------------------------------------
Исключение — это событие при выполнении программы, которое приводит к её ненормальному или неправильному поведению.
Существует два вида исключений:

Аппаратные (структурные, SE-Structured Exception), которые генерируются процессором. К ним относятся, например,
деление на 0;
выход за границы массива;
обращение к невыделенной памяти;
переполнение разрядной сетки.

Программные, генерируемые операционной системой и прикладными программами – возникают тогда, когда программа их
явно инициирует. Когда встречается аномальная ситуация, та часть программы, которая ее обнаружила, может
сгенерировать, или возбудить, исключение.

Обработка программных исключений
Фундаментальная идея обработки исключительных ситуаций состоит в том, что функция, обнаружившая проблему, но не
знающая как её решить, генерирует исключение в надежде, что вызвавшая её (непосредственно или косвенно) функция
сможет решить возникшую проблему. Функция, которая может решать проблемы данного типа, указывает, что она
перехватывает такие исключения.

2. Что такое исключение для Java-программы? Что значит “программа выбросила исключение”? Опишите ситуации, когда
исключения выбрасываются виртуальной машиной(автоматически), и когда необходимо их выбрасывать вручную?
------------------------------------------------------------------------------------------------------------------
В мире программирования возникновение ошибок и непредвиденных ситуаций при выполнении программы называют исключением.
В программе исключения могут возникать в результате неправильных действий пользователя, отсутствии необходимого
ресурса на диске, или потери соединения с сервером по сети.

3. Приведите иерархию классов-исключений, делящую исключения на проверяемые и непроверяемые. В чем особенности
проверяемых и непроверяемых исключений
------------------------------------------------------------------------------------------------------------------
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются
подклассы Exception и Error.

Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемы и предсказуемы.
Например, произошло деление на ноль в целых числах.

Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует
пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения
такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё
равно не сможет обеспечить для JVM.

В Java все исключения делятся на три типа: контролируемые исключения (checked) и неконтролируемые исключения (unchecked),
к которым относятся ошибки (Errors) и исключения времени выполнения (RuntimeExceptions, потомок класса Exception).

Контролируемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу
относятся все потомки класса Exception (но не RuntimeException).

бработка исключения может быть произведена с помощью операторов try…catch, либо передана внешней части программы.
Например, метод может передавать возникшие в нём исключения выше по иерархии вызовов, сам его не обрабатывая.

Неконтролируемые исключения не требуют обязательной обработки, однако, при желании, можно обрабатывать исключения
класса RuntimeException.

4. Объясните работу оператора try-catch-finally. Когда данный оператор следует использовать? Сколько блоков catch может
соответствовать одному блоку try? Можно ли вкладывать блоки try друг в друга, можно ли вложить блок try в catch или
finally? Как происходит обработка исключений, выброшенных внутренним блоком try, если среди его блоков catch нет
подходящего? Что называют стеком операторов try? Как работает блок try с ресурсами.
-----------------------------------------------------------------------------------------------------------------
Кратко о ключевых словах try, catch, finally, throws
Обработка исключений в Java основана на использовании в программе следующих ключевых слов:
try – определяет блок кода, в котором может произойти исключение;
catch – определяет блок кода, в котором происходит обработка исключения;
finally – определяет блок кода, который является необязательным, но при его наличии выполняется в любом случае
независимо от результатов выполнения блока try.
Эти ключевые слова используются для создания в программном коде специальных обрабатывающих конструкций:
try{}catch, try{}catch{}finally, try{}finally{}.
throw – используется для возбуждения исключения;
throws – используется в сигнатуре методов для предупреждения, о том что метод может выбросить исключение.

5. Укажите правило расположения блоков catch в зависимости от типов перехватываемых исключений. Может ли
перехваченной исключение быть сгенерировано снова, и, если да, то как и кто в этом случае будет обрабатывать повторно
сгенерированное исключение? Может ли блок catch выбрасывать иные исключения, и если да, то опишите ситуацию, когда
это может быть необходимо.
------------------------------------------------------------------------------------------------------------------

6. Когда происходит вызов блока finally? Существуют ли ситуации, когда блок finally не будет вызван? Может ли блок finally
выбрасывать исключений? Может ли блок finally выполнится дважды?
-------------------------------------------------------------------------------------------------------------------

finally – определяет блок кода, который является необязательным, но при его наличии выполняется в любом случае
независимо от результатов выполнения блока try.

System.exit отключает виртуальную машину - вызов не происходит

Да, может выкинуть исключение.

Блок finally выполняется вне зависимости от того, было ли выброшено в его блоке try исключение, или нет. Когда
исключение не случилось в try, но случилось в finally, нет ничего интересного. Это исключение как обычно пойдет
вверх по стеку вызовов, пока не попадется в соответствующий ему catch.

Вопрос подразумевает второй случай, когда исполнение попадает в finally в момент выброса исключения из try.
Исключение из finally заменит собой исключение из try и пойдет вверх по стеку вместо него. Оригинальная проблема
будет попросту забыта.

Такая маскировка исключения усложняет отладку, лучше избегать её. Например IntelliJ IDEA выводит соответствующее
предупреждение на оператор throw внутри finally.

Все тонкости прохода исключения через try-catch-finally описаны в разделе 14.20.2 спецификации.