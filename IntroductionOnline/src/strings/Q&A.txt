1. Как создать объект класса String, какие конструкторы класса String вы знаете? Что такое строковый литерал?
Объясните, что значит “упрощенное создание объекта String”?
-----------------------------------------------------------------------------------------------------------------
Строка представляет собой последовательность символов. Для работы со строками в Java определен класс String,
который предоставляет ряд методов для манипуляции строками. Физически объект String представляет собой ссылку
на область в памяти, в которой размещены символы.

Для создания новой строки мы можем использовать один из конструкторов класса String, либо напрямую присвоить
строку в двойных кавычках:

String str1 = "Java";
String str2 = new String(); // пустая строка
String str3 = new String(new char[] {'h', 'e', 'l', 'l', 'o'});
String str4 = new String(new char[]{'w', 'e', 'l', 'c', 'o', 'm', 'e'}, 3, 4);//3 -начальный индекс, 4 -кол-во символов

2. Можно ли изменить состояние объекта типа String? Что происходит при попытке изменения состояния объекта типа
String? Можно ли наследоваться от класса String? Как вы думаете, почему строковые объекты immutable?
-----------------------------------------------------------------------------------------------------------------
Классы объявлены final, поэтому наследоваться не получится.

Почему строка неизменная и финализированная в Java?
Есть несколько преимуществ в неизменности строк:

Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много
места в памяти(heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы
строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо
переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.
Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя
пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании
сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть
изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.
Так как строка неизменная, она безопасна для многопоточности и один экземпляр строки может быть совместно
использован различными нитями. Это позволяет избежать синхронизации для потокобезопасности, строки полностью
потокобезопасны.
Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи
Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс,
но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей
базой данных.
Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова.
Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap.
Это причина, почему строка наиболее часто используемый объект в качестве ключа HashMap.

3. Объясните, что такое кодировка? Какие кодировки вы знаете? Как создать строки в различной кодировке?
------------------------------------------------------------------------------------------------------------------
Символы в компьютере обычно кодируются одним или нескольким байтами (группами из восьми битов).
Хотя термин «набор символов» (англ. character set, charset), узаконенный интернет-стандартом RFC 2278,
сейчас является, пожалуй, наиболее авторитетным, предшествовавший ему термин «кодировка» (англ. encoding)
по-прежнему используется в качестве синонима, в частности, в языках программирования

Нередко также вместо термина «набор символов» неправильно употребляют термин «кодовая страница», означающий на
самом деле частный случай набора символов с однобайтным кодированием.

В настоящее время в основном используются кодировки трёх типов: совместимые с ASCII, совместимые с EBCDIC и
основанные на Юникоде 16-битные, с подавляющим преобладанием первых. Представление UTF-8 Юникода совместимо с ASCII.
Кодировки на базе EBCDIC (например, ДКОИ-8) используются только на некоторых мэйнфреймах. Первоначально в каждой
операционной системе использовался один набор символов. Теперь используемые наборы символов стандартизованы,
зависят от типа операционной системы лишь по традиции и устанавливаются согласно локали.

ASCII
CP1251
CP866
UTF-8

String s = "Good news everyone!";
Charset koi8 = Charset.forName("KOI8-R");
byte[] buffer = s.getBytes(koi8);
byte[] getBytes(Charset charset)

4. Что такое пул литералов? Как строки заносятся в пул литералов? Как занести строку в пул литералов и как получить
ссылку на строку, хранящуюся в пуле литералов? Где хранится(в каком типе памяти) пул литералов в Java 1.6 и Java
1.7?
-----------------------------------------------------------------------------------------------------------------
Пул строк (String Pool) — это множество строк в кучи (Java Heap Memory). Мы знаем, что String — особый класс в
java, с помощью которого мы можем создавать строковые объекты.

Сам строковый пул возможен только потому, что строки в Java неизменные. Также пул строк позволяет сохранить память
в Java Runtime, хотя это и требует больше времени на создание самой строки.

Когда мы используем двойные кавычки, чтобы создать новую строку, то первым делом идет поиск строки с таким же
значением в пуле строк. Если java такую строку нашла, то возвращает ссылку, в противном случае создается новая
строка в пуле, а затем возвращается ссылка.

Однако использование оператора new заставляет класс String создать новый объект String. После этого можем
использовать метод intern(), чтобы поместить этот объект в пул строк или обратиться к другому объекту из пула
строк, который имеет такое же значение.

5. В чем отличие объектов классов StringBuilder и StringBuffer от объектов класса String? Какой из этих классов
потокобезопасный? Как необходимо сравнивать на равенство объекты классов StringBuilder и StringBuffer и почему?
------------------------------------------------------------------------------------------------------------------

Все строковые классы – final (следовательно от них нельзя унаследоваться).

String.
Строка — объект, что представляет последовательность символов. Для создания и манипулирования строками Java
платформа предоставляет общедоступный финальный (не может иметь подклассов) класс java.lang.String. Данный класс
является неизменяемым (immutable) — созданный объект класса String не может быть изменен.

StringBuffer
Строки являются неизменными, поэтому частая их модификация приводит к созданию новых объектов, что в свою очередь
расходует драгоценную память. Для решения этой проблемы был создан класс java.lang.StringBuffer, который позволяет
более эффективно работать над модификацией строки. Класс является mutable, то есть изменяемым — используйте его,
если Вы хотите изменять содержимое строки. StringBuffer может быть использован в многопоточных средах, так как
необходимые методы являются синхронизированными.

StringBuilder
StringBuilder — класс, что представляет изменяемую последовательность символов. Класс был введен в Java 5 и имеет
полностью идентичный API с StringBuffer. Единственное отличие — StringBuilder не синхронизирован. Это означает,
что его использование в многопоточных средах нежелательно. Следовательно, если вы работаете с многопоточностью,
Вам идеально подходит StringBuffer, иначе используйте StringBuilder, который работает намного быстрее в
большинстве реализаций.

6. Что такое Unicode?
------------------------------------------------------------------------------------------------------------------
Юнико́д[1] (чаще всего) или Унико́д[2] (англ. Unicode) — стандарт кодирования символов, включающий в себя знаки почти
всех письменных языков мира[3]. В настоящее время стандарт является преобладающим в Интернете.

Стандарт предложен в 1991 году некоммерческой организацией «Консорциум Юникода» (англ. Unicode Consortium,
Unicode Inc.)[4][5]. Применение этого стандарта позволяет закодировать очень большое число символов из разных
систем письменности: в документах, закодированных по стандарту Юникод, могут соседствовать китайские иероглифы,
математические символы, буквы греческого алфавита, латиницы и кириллицы, символы музыкальной нотной нотации,
при этом становится ненужным переключение кодовых страниц[6].

Стандарт состоит из двух основных частей: универсального набора символов (англ. Universal character set, UCS)
и семейства кодировок (англ. Unicode transformation format, UTF). Универсальный набор символов перечисляет
допустимые по стандарту Юникод символы и присваивает каждому символу код в виде неотрицательного целого числа,
записываемого обычно в шестнадцатеричной форме с префиксом U+, например, U+040F. Семейство кодировок определяет
способы преобразования кодов символов для передачи в потоке или в файле.

7. Какие методы класса String используются для работы с кодовыми точками? Как вы думаете, когда следует их
использовать?

В языке Java строки реализованы как последовательности значений типа char. Тип char позволяет задавать кодовые
единицы, представляющие кодовые точки Unicode в кодировке UTF-16. Наиболее часто используемые символы Unicode
представляются одной кодовой единицей. Дополнительные символы задаются парами кодовых единиц.

Метод length() возвращает количество кодовых единиц для данной строки в кодировке UTF-16. Ниже приведен пример
использования данного метода:

String greeting = "Hello";
int n = greeting.length(); // Значение n равно 5.
Чтобы определить реальную длину, представляющую собой число кодовых точек, надо использовать следующий вызов:

int cpCount = greeting.codePointCount(0, greeting.length());

Метод s.charAt(n) возвращает кодовую единицу в позиции n, где n находится в интервале от 0 до s.length() - 1.
Ниже приведены примеры вызова данного метода.

char first = greeting.charAt(0); // первый символ - 'H'char last = greeting.charAt(4); // последний символ - 'o'

Для получения i-й кодовой точки надо использовать приведенные ниже выражения.

int index = greeting.offsetByCodePoints(0, i);
int cp = greeting.codePointAt(index);
Java подсчитывает кодовые единицы в строках специфическим образом: первая кодовая единица в строке расположена
в позиции 0. Это соглашение пришло из языка C, где по техническим причинами подсчет позиций начинается с 0.
Эта причина давно ушла в прошлое, а неудобство осталось. Однако этому соглашению следует настолько много
программистов, что проектировщики Java решили сохранить его.

Regular Expressions

1. Расскажите, что представляет собой регулярное выражение? Что такое метасимволы регулярного выражения? Какие вы
знаете классы символов регулярных выражений? Что такое квантификаторы? Какие логические операторы регулярных
выражений вы знаете? Что значит “якорь” для регулярного выражения?
-----------------------------------------------------------------------------------------------------------------

Регулярные выражениия (англ. regular expressions) — формальный язык поиска и осуществления манипуляций с подстроками
в тексте, основанный на использовании метасимволов (символов-джокеров, англ. wildcard characters). Для поиска
используется строка-образец (англ. pattern, по-русски её часто называют «шаблоном», «маской»), состоящая из
символов и метасимволов и задающая правило поиска. Для манипуляций с текстом дополнительно задаётся строка замены,
которая также может содержать в себе специальные символы.

Подробнее: http://website-lab.ru/article/regexp/shpargalka_po_regulyarnyim_vyirajeniyam/

2. Какие java-классы работают с регулярными выражениями? В каком пакете они расположены? Приведите пример анализа
текста с помощью регулярного выражения и поясните код примера.
------------------------------------------------------------------------------------------------------------------
Подробнее: https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java

3. Что такое группы в регулярных выражениях? Как нумеруются группы? Что представляет собой группа номер 0(ноль)?
Приведите пример с использованием групп регулярного выражения.
------------------------------------------------------------------------------------------------------------------
Подробнее: https://learn.javascript.ru/regexp-groups
