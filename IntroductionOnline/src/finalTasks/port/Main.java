package finalTasks.port;

import java.util.Random;

/**
 * Task 4. Multithreading
 *
 * Описание к этой задаче я напишу на русском.
 *
 * Конкретизируем условие задачи. Есть один порт. Количество причалов влияет лишь на скорость решения задачи,
 * более важными являются параметры CONTAINERS_IN_PORT - изначальное количество контейнеров в порту и
 * CAPACITY_OF_PORT - вместимость порта.
 *
 * Генерируем n кораблей. В примере ниже и для конкретики объяснения n = 10. Их средняя вместимость (capacity)
 * будет равна 7.5. Средняя изначальная загрузка (loading) судна будет равна половине средней вместительности, то
 * есть 3.75.
 *
 * Будем считать, что корабль сначала должен разгрузится полностью, а потом полностью загрузиться, иначе нужны
 * какие-либо дополнительные условия, но в любом случае (что логично), сначала разгрузка, потом загрузка, и к тому
 * же последовательно. Одновременная разгрузка и загрузка одного корабля также требует доп. условий.
 *
 * Корабли могут приходить (случайным образом или принудительно) полностью загруженными или совсем пустыми
 *
 * Исходя из выше сказанного, в порту должно всегда хватать контейнеров на загрузку всех 10 судов. Корабли с собой
 * привозят в среднем 38 контейнеров, а увозят 75, то есть они всегда (кроме особых случаев) увозят больше, чем
 * привезли. Таким образом изначально в порту должна быть разница. Средняя разница (38) - дает средний результат, то
 * есть иногда контейнеров хватает всем кораблям, а иногда нет. Для данного примера при CONTAINERS_IN_PORT = 55
 * контейнеров всем хватает.
 *
 * Если принудительно установить все суда пустыми (loading = 0), то в порту должно быть больше 75 контейнеров.
 * Устойчиво всем десяти кораблям хватает 85 контейнеров.
 *
 * Если принудительно установить всем судам загрузку под 100% (loading = capacity), то контейнеры в порту не
 * требуются. Можно выставить CONTAINERS_IN_PORT = 0 и по окончанию задачи в порт также будет пуст.
 *
 * Так как сначала происходит разгрузка, то в порту должно быть место для разгрузки. Запас в 10 контейнеров
 * достаточен. Также эту задачу можно решить, принудительно всегда добавляя пустое судно. Если все корабли полностью
 * загружены и никто не может разгрузится - задача зависает. Другими словами CAPACITY_OF_PORT - CONTAINERS_IN_PORT
 * должно быть больше 10, иначе при определенных условиях даже чисто физически невозможно обслужить данные суда в
 * данном порту. Ни одно судно не может полнолстью разгрузиться.
 *
 * Предусмотрена частичная загрузка/загрузка и далее выход из дока, но не из порта. Из порта судно выходит только
 * полностью загруженным. Если, например, во все доки вошли суда и не смогли разгрузится (порт переполнен) и в
 * очереди нет пустых судов - задача не решаема. Можно отсортировать суда и обрабатывать сначала небольшие, но это
 * меняет условие задачи....
 */

public class Main {

    private static final int CONTAINERS_IN_PORT = 55;
    private static final int CAPACITY_OF_PORT = 65;
    private static final int COUNT_OF_DOCKS = 3;
    private static final int COUNT_OF_SHIPS = 10;

    public static void main(String[] args) {
        Random random = new Random();
        Port port = new Port(CONTAINERS_IN_PORT, CAPACITY_OF_PORT, COUNT_OF_DOCKS);
        for (int i = 0; i < COUNT_OF_SHIPS; i++) {
            int capacity = 5 + random.nextInt(6);
            int loading = random.nextInt(capacity);
            new Thread(new Ship(port, loading, capacity), "Ship_" + i).start();
        }
    }
}
